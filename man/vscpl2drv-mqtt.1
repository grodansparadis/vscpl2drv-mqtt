.\"t
.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "vscpl2drv\-mqtt" "1" "September 28, 2019" "VSCP Level II MQTT Driver" ""
.hy
.SH NAME
.PP
vscpl2drv\-mqtt \- VSCP Level I MQTT Driver
.SH SYNOPSIS
.PP
vscpl2drv\-mqtt
.SH DESCRIPTION
.PP
MQTT provides a lightweight method of carrying out messaging using a
publish/subscribe model.
This makes it suitable for \[lq]machine to machine\[rq] messaging such
as with low power sensors or mobile devices such as phones, embedded
computers or micro controllers like the Arduino.
A good example of this is all of the work that Andy Stanford\-Clark IBM
(one of the originators of MQTT) has done in home monitoring and
automation with his twittering house and twittering ferry.
The MQTT protocol is now an ISO standard maintained by OASIS.
.PP
This driver allow publishing of VSCP events as well as subscribing to
VSCP events.
To build and use the driver you need yo install the Mosquitto library.
You can find instruction on how to do that
here (https://grodansparadis.gitbooks.io/the-vscp-daemon/installing_moquitto_for_use_with_vscp.md).
.SS Configuration string
.PP
The configuration string have the following format
.IP
.nf
\f[C]
“sessionid";"subscribe”|”publish”;channel;host;user;password;keepalive;filter;mask
\f[]
.fi
.PP
The first configuration parameter is a unique id like
\[lq]mysession22\[rq] for your connection.
The second parameter tell if the intention is to subscribe
(\[lq]subscribe\[rq]) to an existing MQTT channel or to publish
(\[lq]publish\[rq]) events on a channel.
The second parameter is the topic.
This is a text string identifying the topic.
It is recommended that this string starts with \[lq]vscp/\[rq].
Host is the host where the MQTT broker is located (defaults to
\[lq]localhost:1883\[rq]).
Note that port must be included in the hostname.
User/password is credentials for the channel if they are needed.
.PP
The configuration string is the first configuration data that is read.
The driver will, after it is read, ask the server for driver specific
configuration data.
This data is fetched with the same pattern for all drivers.
Variables are formed by the driver name + some driver specific variable
name.
If this variable exist and contains data this will be used as
configuration for the driver.
.PP
For the vscpl2drv\-mqtt the following configuration variables are
defined
.PP
.TS
tab(@);
lw(32.5n) cw(10.0n) lw(27.5n).
T{
Variable name
T}@T{
Type
T}@T{
Description
T}
_
T{
**_path**
T}@T{
string
T}@T{
Path to the logfile.
T}
T{
**_rewrite**
T}@T{
bool
T}@T{
Set to \[lq]true\[rq] to rewrite the file each time the driver is
started.
Set to \[lq]false\[rq] to append to file.
T}
T{
**_vscpworksfmt**
T}@T{
bool
T}@T{
If \[lq]true\[rq] VSCP works XML format will be used for the log file.
This means that the file will be possible to read and further analyzed
by VSCP Works.
If \[lq]false\[rq] a standard text based format will be used.
T}
T{
**_filter**
T}@T{
string
T}@T{
Standard VSCP filter in string from.
1,0x0000,0x0006,ff:ff:ff:ff:ff:ff:ff:01:00:00:00:00:00:00:00:00 as
priority,class,type,GUID
T}
T{
**_mask**
T}@T{
string
T}@T{
Standard VSCP mask in string form.
1,0x0000,0x0006,ff:ff:ff:ff:ff:ff:ff:01:00:00:00:00:00:00:00:00 as
priority,class,type,GUID
T}
.TE
.SS Remote variables
.PP
.TS
tab(@);
lw(32.5n) lw(10.0n) lw(27.5n).
T{
Variable name
T}@T{
Type
T}@T{
Description
T}
_
T{
**_sessionid**
T}@T{
string
T}@T{
A unique session id (\[lq]myconnection2\[rq]) you set for every
connection to a broker.
The session id's must be different if load several MQTT drivers and also
so if the connect to the same broker.
Available from version 1.1.0.22 Sodium.
T}
T{
**_type**
T}@T{
string
T}@T{
\[lq]subscribe\[rq] to subscribe to a MQTT topic.
”publish” to publish events to a MQTT topic.
Defaults to \[lq]subscribe\[rq].
T}
T{
**_topic**
T}@T{
string
T}@T{
This is a text string identifying the topic.
It is recommended that this string starts with \[lq]vscp/\[rq].
Defaults to \[lq]vscp\[rq]
T}
T{
**_host**
T}@T{
string
T}@T{
IP address or a DNS resolvable address to the remote host.
Mandatory and must be declared either in the configuration string or in
this variable.
\f[B]Note that port must be included in the hostname.\f[] Defaults to
\[lq]localhost:1883\[rq]
T}
T{
**_user**
T}@T{
string
T}@T{
Username used to log in on the remote MQTT sever.
Defaults to empty.
Currently not used.
T}
T{
**_password**
T}@T{
string
T}@T{
Password used to login on the remote MQTT server.
Defaults to empty.
Currently not used.
T}
T{
**_keepalive**
T}@T{
integer
T}@T{
Keepalive value for channel.
Defaults to 60.
T}
T{
**_filter**
T}@T{
string
T}@T{
Standard VSCP filter in string form.
1,0x0000,0x0006,ff:ff:ff:ff:ff:ff:ff:01:00:00:00:00:00:00:00:00 as
priority,class,type,GUID Used to filter what events that is received
from the socketcan interface.
If not give all events are received/sent.
T}
T{
**_mask**
T}@T{
string
T}@T{
Standard VSCP mask in string form.
1,0x0000,0x0006,ff:ff:ff:ff:ff:ff:ff:01:00:00:00:00:00:00:00:00 as
priority,class,type,GUID Used to filter what events that is received
from the socketcan interface.
If not give all events are received/sent.
T}
T{
**_simplify**
T}@T{
string
T}@T{
Makes it possible to publish and subscribe data in a human handleable
form.
See below for more information.
T}
.TE
.PP
The full variable name is built from the name you give the driver
(prefix before _variablename) in vscpd.conf.
So in the examples below the driver have the name \f[B]mqtt1\f[] and the
full variable name for the **_sessionid** will thus be
.IP
.nf
\f[C]
mqtt1_sessionid
\f[]
.fi
.PP
If you have another driver and name it \f[B]mqtt2\f[] it will therefore
instead request variable
.IP
.nf
\f[C]
mqtt2_sessionid
\f[]
.fi
.PP
and so on.
.PP
If your driver name contains spaces, for example \[lq]name of
driver\[rq] it will get a prefix that is \[lq]name_of_driver\[rq].
Leading and trailing spaces will be removed.
.SS _simplify
.PP
If this variable is defined it will simplify the effort to publish
measurement or subscribe to measurement information.
It makes it as simple as 1\-2\-3 and allows for sending just numbers
over MQTT but still get valid events into the system.
The functionality works also the other way around so measurement events
can send data over MQTT as just a number possibly using the MQTT topic
as a way to tell what is sent.
.PP
For a publishing channel it may be wise to set a filter in the driver so
only the events of interest is published.
.PP
The format for the simplicity variable varies for the VSCP class one
want to use
.PP
\f[B]CLASS1.MEASUREMENT (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.measurement.html)\f[]
.PP
Only \f[B]string\f[] and \f[B]float\f[] coding is allowed.
For string the number can be a maximum of seven characters.
.PP
The variable format is
.RS
.PP
10, vscp\-type,float|string, sensoridx(0\-7), unit(0\-7)
.RE
.PP
(VSCP types are
here (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.measurement.html))
so if you code a simplify variable as
.RS
.PP
10,6,float,3,1
.RE
.PP
for a subscribe setup a number like \[lq]23.78\[rq] send over MQTT will
be converted to a valid VSCP event CLASS1.MEASUREMENT, Type=6,
temperature (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.measurement.html#type6)
and with unit set to degrees Celsius and sensor index set to 2 and where
the data is a single precision floating point number (32\-bit).
The setup is of course the same for a publish setup.
\f[B]The GUID for the interface will be used\f[].
.PP
If you select a float or a string is just a matter of preference in most
cases but the floating point value is often the best choice.
.PP
\f[B]CLASS2.MEASUREMENT_FLOAT (https://grodansparadis.gitbooks.io/the-vscp-specification/class2.measurement_float.html)\f[]
.PP
If you need a floating point value with more precision this is the
choice.
It uses a double (64\-bit) double precision floating point number.
.PP
The variable format is
.RS
.PP
1060, vscp\-type, sensoridx(0\-255), unit(0\-255), zone(0\-255),
subzone(0\-255)
.RE
.PP
(VSCP types are
here (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.measurement.html))
.PP
\f[B]CLASS2.MEASUREMENT_STR (https://grodansparadis.gitbooks.io/the-vscp-specification/class2.measurement_str.html)\f[]
.PP
This measurement format allow for a decimal measurement (\[lq].\[rq] is
decimal separator) which allow for a maximum of 483 digits including a
possible decimal point.
So if you need a lot of numbers this is the format for you.
.PP
The variable format is
.RS
.PP
1040, vscp\-type, sensoridx(0\-255), unit(0\-255), zone(0\-255),
subzone(0\-255)
.RE
.PP
(VSCP types are
here (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.measurement.html))
.SS vscpd.conf example
.IP
.nf
\f[C]
<driver\ enable="true"\ >
\ \ \ \ <name>mqtt1`</name>
\ \ \ \ <path>/usr/local/lib/vscp2drv_mqtt.so</path>
\ \ \ \ <config>"mysession1";publish;vscp;localhost:1883</config>
\ \ \ \ <guid>`00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00</guid>
</driver>
\f[]
.fi
.PP
The format for data on the MQTT wire is the same as the format for sends
and receives in the TCP/IP interface.
This means they look like this
.RS
.PP
head,class,type,obid,datetime,timestamp,GUID,data0,data1,data2,\&...
.RE
.PP
and as usual the GUID can be replaced by \[lq]\-\[rq] to use the
interface GUID.
.PP
Using the methods
.IP \[bu] 2
vscphlp_writeVscpEventToString
.IP \[bu] 2
vscphlp_writeVscpEventExToString
.IP \[bu] 2
vscphlp_setVscpEventFromString
.IP \[bu] 2
vscphlp_setVscpEventExFromString
.PP
available in the vscphelper library (C/C++/C#/Python/PHP/node.js) it is
easy to convert between VSCP Event and text form.
It is also very easy to get other properties from the event such as real
number measurement with the help of the same library.
.SH Using the MQTT driver
.PP
MQTT is a protocol for M2M by IBM.
This driver makes it possible to use MQTT as the transport for VSCP
events.
As MQTT, with the help of IBM's muscle mass, is available on many, many
platforms this can be a way to enter events into or fetch events from
the VSCP framework.
Thus any device that can use MQTT can connect to a websocket button or
show it's data in a table or log data to a database.
.PP
For measurements it be as easy as 1\-2\-3.
You just send or fetch data and the driver do the VSCP translations to
full events for you.
.SS Setting up the needed MQTT subsystem
.PP
\f[I]This has been tested on several Debian and Ubuntu boxes and on a
Rasbian driven Raspberry Pi board. On all I tested you can jump directly
to step 4. If that does not work start at step 1.\f[]
.PP
To use the driver the MQTT Mosquitto (https://mosquitto.org/) or similar
broker is needed.
To do this follow the steps below.
Taken from here (installing_moquitto_for_use_with_vscp.md)
.SS Install a MQTT broker and a client
.PP
Install the Mosquitto server and clients
.RS
.PP
$ sudo apt install mosquitto $ sudo apt install mosquitto\-clients
.RE
.PP
You are now ready to use the MQTT subsystem.
.PP
To test that everything works you can now open a terminal window and
issue
.RS
.PP
$ mosquitto_sub \-d \-t hello/world
.RE
.PP
to subscribe to the \f[B]hello/world\f[] channel.
And then open another terminal window and issue
.RS
.PP
$ mosquitto_pub \-d \-t hello/world \-m \[lq]Hello World\[rq]
.RE
.PP
if everything works \[lq]Hello World\[rq] will come up in the subscribe
window.
You can of course do this on different machines also.
On one machine issue
.RS
.PP
$ mosquitto_sub \-h YOUR_HOST_IP_ADDRESS \-d \-t hello/world
.RE
.PP
and on the other issue
.RS
.PP
$ mosquitto_pub \-d \-t hello/world \-m \[lq]Hello World\[rq]
.RE
.PP
as before.
If this does not work you may need to open the 1883 port in your
firewall.
For this use
.RS
.PP
sudo iptables \-A INPUT \-p tcp \-m tcp \[en]dport 1883 \-j ACCEPT
.RE
.SS Setting up the MQTT driver
.PP
You can find the documentation for the driver
here (./level2_driver_mqtt.md)
.SS Publish
.PP
The first thing you should do is to add the driver to the VSCP daemon
configuration file.
To do this look up the \f[C]<vscpdriver>\f[] \&...
\f[C]</vscpdriver>\f[] tags in the file and add
.IP
.nf
\f[C]
<driver\ enable="true">
\ \ \ \ <name>VSCP\ MQTT\ Publisher\ driver\ 1</name>
\ \ \ \ <path>/usr/local/lib/vscpl2drv_mqtt.so</path>
\ \ \ \ <config>mysession2;publish;vscp;localhost:1883</config>
\ \ \ \ <guid>00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00`</guid>
</driver>`
\f[]
.fi
.PP
Select a name that works for you.
\f[B]enable\f[] should be set to \f[I]true\f[] for the driver to be
loaded and to \f[I]false\f[] if not.
This can be convenient if you want to have a driver in the configuration
file but not want to enable it.
.PP
The \f[B]path\f[] may be different on your system but
\f[I]/usr/local/bin\f[] is the default installation path on most
systems.
Replace with the correct path if its different on your system.
.PP
\f[B]GUID\f[] is all set no zeros here which means the GUID of the
interface will be used.
You can leave it out if you want to give the same effect or you can set
it to a unique id.
.PP
The \f[B]config\f[] item tells how your driver should work.
It is a semicolon separated list with items that is fully described in
the specification document.
.PP
The first item in this list can be \f[I]subscribe\f[] or
\f[I]publish\f[] depending if you want VSCP events to be sent or
received, publish is used in this example as we want to publish events.
.PP
The second is the the \f[B]topic\f[].
This is the MQTT term for a channel and is a slash separated list.
You can use anything here but staring your topic with \f[I]vscp\f[] is
recommended.
We use vscp here but could have used
vscp/measurements/temperature/celsius or something similar instead.
Use the topic that works for you.
.PP
Next is the host where your Mosquitto daemon is installed (defaults to
\[lq]localhost:1883\[rq]) and must include the port and the host is
followed by an optional username and password.
.PP
To this list you can add a keepalive value which is the number of
seconds the server expect to be feed with messages (Defaults to one
minute) and a usual event filter/mask pair to select which events should
be published or be received.
.PP
Restart the daemon with
.RS
.PP
$ sudo /etc/init.d/vscpd restart
.RE
.PP
and subscribe to the published events with
.RS
.PP
$ mosquitto_sub \-d \-t vscp
.RE
.PP
Events is presented in the form
.RS
.PP
head,class,type,obid,datetime,timestamp,GUID,data0,data1,data2,\&...\&...\&.....
.RE
.PP
by default (this can be changed see below).
You can use the helper library and the methods
.IP \[bu] 2
writeVscpEventToString
.IP \[bu] 2
writeVscpEventExToString
.IP \[bu] 2
getVscpEventFromString
.IP \[bu] 2
getVscpEventExFromString
.IP \[bu] 2
getVSCPDataCodingAsString
.IP \[bu] 2
getDataCodingFloat
.PP
to easily interpret the event.
.PP
You can easily control that the driver is loaded by using the internal
web interface of the daemon and open
.RS
.PP
http://localhost:8884/vscp/interfaces
.RE
.PP
replacing
.RS
.PP
http://localhost:8884
.RE
.PP
with your actual host and port.
This will show something like this
.PP
[IMAGE: interfaces2.png (./images/interfaces2.png)]
.PP
where the driver with the name you given it will be visible in the list.
.SS Subscribe
.PP
To subscribe to events on a channel use \f[I]subscribe\f[] instead of
\f[I]publish\f[] above.
.IP
.nf
\f[C]
<driver\ enable="true"\ >
\ \ \ \ <name>VSCP\ MQTT\ Subscriber\ driver\ 1</name>
\ \ \ \ <path>/usr/local/lib/vscp2drv_mqtt.so</path>
\ \ \ \ <config>subscribe;vscp;localhost:1883</config>
\ \ \ \ <guid>00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00</guid>
</driver>
\f[]
.fi
.PP
When the server is restarted and the driver is loaded you can publish
VSCP events with
.RS
.PP
$ mosquitto_pub \-d \-t vscp \-m
\[lq]0,20,3,0,0,0:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15,0,1,35\[rq]
.RE
.PP
or
.RS
.PP
$ mosquitto_pub \-d \-t vscp \-m \[lq]0,20,3,0,0,\-,0,1,35\[rq]
.RE
.PP
both of these will publish the VSCP event CLASS1.INFORMATION TYPE=3
ON (https://grodansparadis.gitbooks.io/the-vscp-specification/class1.information.html#type3)
event, for zone=1, sub\-zone=35 typically used to tell that something
has been turned on in zone=1, subzone=35.
In the first case a specific GUID is used
(0:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15) and in the second the GUID of
the interface has been used.
You can use the interface GUID also by specifying the GUID to all nills
(00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00) as always.
.PP
Use VSCP Works to examine published events received by the MQTT driver
in a user friendly way or telnet to the TCP/IP interface of the daemon
.RS
.PP
$ telnet localhost 9598
.RE
.PP
login with
.RS
.PP
$ user admin $ pass secret
.RE
.PP
works on a newly installed system with the default configuration.
Otherwise replace with your own credentials and also the host you have
the daemon on of course if your not located at the same host.
.PP
use
.RS
.PP
$ retr
.RE
.PP
to retrieve one event from the input queue
.PP
or
.RS
.PP
$ retr 25
.RE
.PP
if you want to fetch 25 or all that is collected.
You can also use
.RS
.PP
$ rcvloop
.RE
.PP
to see incoming events (use `quitloop' to terminate the loop).
The \[lq]+OK\[rq] you may see from time to time is a way for M2M
routines to know the line is open as this is intended for machines.
.PP
In both cases events will be presented as
.IP
.nf
\f[C]
head,class,type,obid,datetime,timestamp,GUID,data0,data1,data2,...........
\f[]
.fi
.PP
All command of the daemon is described
here (./tcp_ip_control_interface.md).
.SS Using remote variables
.PP
The configure string in the VSCP daemon driver configuration can be
replaced by VSCP variables instead.
Actually a value specified in a variable will be used before a value in
a configuration string.
So if you have both the variable value will have precedence.
.PP
All the variables for the MQTT driver is defined
here (./level2_driver_mqtt.md).
There is one each for the configuration values defined above.
.PP
There is **\f[I]type** which in our case is the variable
\f[BI]vscp_mqtt_publisher_driver_1_type\f[I] and
\f[BI]vscp_mqtt_subscriber_driver_1_type\f[I]. As you see the driver
name is prepended to the variable name (with spaces replaced by "\f[]")
to get the actual variable name.
This method makes it possible to have several channels open at the same
time with different configurations as long as they have different names.
The _type variable can have the value \[lq]subscribe\[rq] or
\[lq]publish\[rq] and is a variable of string type.
.PP
You can create a variable in two ways.
.PP
Either you add them by hand to the variables configuration file in
\f[I]/etc/vscp/variables.xml\f[].
So in this case you enter
.IP
.nf
\f[C]
<variable\ type="string"\ >
\ \ \ \ <name>vscp_mqtt_publisher_driver_1_type</name>
\ \ \ \ <value>publish</value>
\ \ \ \ <note>bla\ bla\ bla\ bla</note>
</variable>
\f[]
.fi
.PP
and/or
.IP
.nf
\f[C]
<variable\ type="string"\ >
\ \ \ \ <name>vscp_mqtt_subscriber_driver_1_type</name>
\ \ \ \ <value>subscribe</value>
\ \ \ \ <note>bla\ bla\ bla\ bla</note>
</variable>
\f[]
.fi
.PP
but is is probably easier to use the built in web interface of the
daemon to do the same thing.
Head your browser to
.IP
.nf
\f[C]
http://localhost:8884/vscp/varnew
\f[]
.fi
.PP
replacing <http://localhost:8884> with your actual \f[I]host\f[] and
\f[I]port\f[].
.PP
In this first screen you select the value to be a \f[I]string\f[] and
then move on with the \f[I]next\f[] button \\
.PP
[IMAGE: image (./images/drivers/mqtt/variable_string_edit_step1.png)]
.PP
In the next screen you enter the name and the value for the variable as
you did above and also make sure to mark persistent so the variable will
be saved and thus available also after the daemon has been restarted.
When you are ready press save
.PP
 (./images/drivers/mqtt/variable_string_edit_step2.png)
.PP
which will take you back to the variable list where you can click on any
item to edit it.
.PP
 (./images/drivers/mqtt/variable_string_edit_step3.png)
.SS Example: Subscribing
.PP
If you enter a driver entry like this in the
\f[I]/etc/vscp/vscpd.conf\f[] file
.IP
.nf
\f[C]
<driver\ enable="true"\ >
\ \ \ \ <name>VSCPMQTTDriver1</name>
\ \ \ \ <path>/usr/local/lib/vscp2drv_mqtt.so</path>
\ \ \ \ <config>mysession3;publish;vscp1;localhost:1883</config>
\ \ \ \ <guid>00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00</guid>
</driver>
\f[]
.fi
.PP
you can subscribe to the events published using
.IP
.nf
\f[C]
mosquitto_sub\ \-d\ \-t\ vscp1
\f[]
.fi
.PP
And if for instance you have a temperature sensor in your system you
will get events looking like this
.IP
.nf
\f[C]
0,10,6,FF:EE:DD:CC:BB:AA:99:88:77:66:55:43:00:16:00:00,0x68,0x44
\f[]
.fi
.PP
This is the textual representation of a VSCP event.
It has the form
.IP
.nf
\f[C]
head,class,type,obid,datetime,timestamp,guid,data,,,
\f[]
.fi
.PP
The \f[B]GUID\f[] (always presented in hexadecimal) tells from which
interface or device/sensor this event comes from.
It as all data in VSCP comes with the MSB byte first.
.PP
class and type is the event class and the event type, In this case
\f[I]class=10\f[] so we know its a \f[B]CLASS1.MEAUREMENT\f[] and type=6
so we can tell this is a measurement of a temperature.
\f[B]CLASS1.MEAUREMENT\f[] gives information about how the data that
follows is packed.
As we see there is two databytes 0x68 and 0x44.
For \f[B]CLASS1.MEAUREMENT\f[] the first byte of the data is a data
coding byte which tells how the rest of the data is coded in the upper
three bits.
In this case 0x68 = 01101000 the upper bits are 011 which says an
integer follows.
An integer that can take up 1\-7 byte with the most significant byte
first.
In this case our integer is juts one byte.
.PP
So what we have is the temperature 0x44 which is 68 in decimal.
But in what unit is it presented?
To know that we can investigate bit 3 and 4 which are 01 which in turns
tell us that it is a temperature reading in Celsius.
It could have been 00 for a Kelvin reading or 10 for a Fahrenheit
reading.
.PP
The lowest three bits are all zero here but could have been an index
(0\-7) to a specific sensor on the device that is identified by GUID
.PP
\f[B]FF:EE:DD:CC:BB:AA:99:88:77:66:55:43:00:16:00:00\f[]
.SS More to read
.IP \[bu] 2
Using the VSCP MQTT driver Part
1 (https://grodansparadis.com/wordpress/?p=1533)
.IP \[bu] 2
Using the VSCP MQTT driver Part
2 (https//grodansparadis.com/wordpress/?p=1528)
.IP \[bu] 2
MQ Telemetry Transport \- https://mqtt.org/
.IP \[bu] 2
MQTT V3.1 Protocol Specification \-
https://public.dhe.ibm.com/software/dw/webservices/ws\-mqtt/mqtt\-v3r1.html#keep\-alive\-timer
.IP \[bu] 2
Mosquitto \- https://mosquitto.org/
.IP \[bu] 2
Using the API \- https://www.eclipse.org/paho/files/mqttdoc/Cclient/
.IP \[bu] 2
MQTT på arduino \- https://knolleary.net/arduino\-client\-for\-mqtt/
.PP
   *   *   *   *   *
.PP
There are many Level I drivers available in VSCP & Friends framework
that can be used with both VSCP Works and the VSCP Daemon and added to
that Level II and Level III drivers that can be used with the VSCP
Daemon.
.PP
Level I drivers is documented
here (https://grodansparadis.gitbooks.io/the-vscp-daemon/level_i_drivers.html).
.PP
Level II drivers is documented
here (https://grodansparadis.gitbooks.io/the-vscp-daemon/level_ii_drivers.html)
.PP
Level III drivers is documented
here (https://grodansparadis.gitbooks.io/the-vscp-daemon/level_iii_drivers.html)
.SH SEE ALSO
.PP
\f[C]vscpd\f[] (8).
\f[C]uvscpd\f[] (8).
\f[C]vscpworks\f[] (1).
\f[C]vscpcmd\f[] (1).
\f[C]vscp\-makepassword\f[] (1).
\f[C]vscphelperlib\f[] (1).
.PP
The VSCP project homepage is here <https://www.vscp.org>.
.PP
The manual (https://grodansparadis.gitbooks.io/the-vscp-daemon) for
vscpd contains full documentation.
Other documentation can be found here
<https://grodansparadis.gitbooks.io>.
.PP
The vscpd source code may be downloaded from
<https://github.com/grodansparadis/vscp>.
Source code for other system components of VSCP & Friends are here
<https://github.com/grodansparadis>
.SH COPYRIGHT
.PP
Copyright 2000\-2019 Åke Hedman, Grodans Paradis AB \- MIT license.
.SH AUTHORS
Åke Hedman, Grodans Paradis AB.
